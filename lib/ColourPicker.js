// Generated by CoffeeScript 1.3.3
(function() {
  var ColourCalculator, ColourCalculatorHSV, ColourCalculatorRGB, ColourPicker, MouseTouchHandler, MouseTouchHandlerPicker, MouseTouchHandlerSpectrum,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  ColourCalculator = (function() {

    function ColourCalculator() {}

    ColourCalculator.prototype.getHEX = function() {
      this._calculateHEX();
      return this.hex;
    };

    ColourCalculator.prototype.getHSV = function(raw) {
      this._calculateHSV();
      raw = raw || false;
      if (raw !== true) {
        return [Math.round(this.h * 60), Math.round(this.s * 100), Math.round(this.v * 100)];
      } else {
        return [this.h, this.s, this.v];
      }
    };

    ColourCalculator.prototype.getRGB = function(raw) {
      this._calculateRGB();
      raw = raw || false;
      if (raw !== true) {
        return [Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255)];
      } else {
        return [this.r, this.g, this.b];
      }
    };

    ColourCalculator.prototype.getRGBA = function() {
      var raw;
      this._calculateRGB();
      raw = raw || false;
      if (raw !== true) {
        return [Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255), this.alpha];
      } else {
        return [this.r, this.g, this.b, this.alpha];
      }
    };

    ColourCalculator.prototype._calculateHEX = function() {
      var c, rgb, _i, _len, _results;
      rgb = this.getRGB();
      this.hex = '#';
      _results = [];
      for (_i = 0, _len = rgb.length; _i < _len; _i++) {
        c = rgb[_i];
        _results.push(this.hex += ("0" + parseInt(c, 10).toString(16)).slice(-2));
      }
      return _results;
    };

    ColourCalculator.prototype._calculateHSV = function() {
      var delta, max, min;
      if (typeof this.s !== "undefined") {
        return;
      }
      min = Math.min(this.r, this.g, this.b);
      max = Math.max(this.r, this.g, this.b);
      delta = max - min;
      this.v = max;
      if (max === 0) {
        this.s = 0;
        return this.h = -1 / 60;
      } else {
        this.s = delta / max;
        if (this.r === max) {
          return this.h = (this.g - this.b) / delta;
        } else if (this.g === max) {
          return this.h = 2 + (this.b - this.r) / delta;
        } else {
          return this.h = 4 + (this.r - this.g) / delta;
        }
      }
    };

    /*
    Per: http://en.wikipedia.org/wiki/HSL_and_HSV#From_HSV
    */


    ColourCalculator.prototype._calculateRGB = function() {
      var _f, _i, _p, _q, _t;
      if (typeof this.r !== "undefined") {
        return;
      }
      if (this.s === 0) {
        return this.r = this.g = this.b = this.v;
      } else {
        _i = Math.floor(this.h);
        _f = this.h - _i;
        _p = this.v * (1 - this.s);
        _q = this.v * (1 - this.s * _f);
        _t = this.v * (1 - this.s * (1 - _f));
        switch (_i) {
          case 0:
            this.r = this.v;
            this.g = _t;
            return this.b = _p;
          case 1:
            this.r = _q;
            this.g = this.v;
            return this.b = _p;
          case 2:
            this.r = _p;
            this.g = this.v;
            return this.b = _t;
          case 3:
            this.r = _p;
            this.g = _q;
            return this.b = this.v;
          case 4:
            this.r = _t;
            this.g = _p;
            return this.b = this.v;
          case 5:
            this.r = this.v;
            this.g = _p;
            return this.b = _q;
        }
      }
    };

    return ColourCalculator;

  })();

  ColourCalculatorHSV = (function(_super) {

    __extends(ColourCalculatorHSV, _super);

    function ColourCalculatorHSV(h, s, v) {
      this.h = h;
      this.s = s;
      this.v = v;
      while (this.h >= 360) {
        this.h -= 360;
      }
      while (this.h < 0) {
        this.h += 360;
      }
      if (this.s < 0 || this.s > 100) {
        this.s = this.s < 0 ? 0 : 100;
      }
      if (this.v < 0 || this.v > 100) {
        this.v = this.v < 0 ? 0 : 100;
      }
      this.h /= 60;
      this.s /= 100;
      this.v /= 100;
    }

    return ColourCalculatorHSV;

  })(ColourCalculator);

  ColourCalculatorRGB = (function(_super) {

    __extends(ColourCalculatorRGB, _super);

    function ColourCalculatorRGB(r, g, b, alpha) {
      var _ref;
      this.r = r;
      this.g = g;
      this.b = b;
      this.alpha = alpha;
      this.r /= 255;
      this.g /= 255;
      this.b /= 255;
      this.alpha = (_ref = this.alpha) != null ? _ref : 255;
    }

    return ColourCalculatorRGB;

  })(ColourCalculator);

  ColourPicker = (function() {

    function ColourPicker(_plugin) {
      this._plugin = _plugin;
      this._ctxObjects = {};
      this._pickerData = this._plugin.options.pickerData;
      this._spectrumData = this._plugin.options.spectrumData;
    }

    ColourPicker.prototype.build = function() {
      this.buildSpectrum();
      this.buildPicker();
      new MouseTouchHandlerPicker(this._ctxObjects.picker, this);
      return new MouseTouchHandlerSpectrum(this._ctxObjects.spectrum, this);
    };

    ColourPicker.prototype.buildPicker = function() {
      var col, ctx, h, height, i, picker, rgb, row, s, v, width, _h, _ref, _s, _v;
      ctx = (_ref = this._ctxObjects.picker) != null ? _ref : this._createCTXObject('picker', 'colourpicker');
      width = ctx.canvas.width;
      height = ctx.canvas.height;
      picker = this._createImageData(ctx, width, height);
      h = this._pickerData.selectedHSV[0];
      s = 0;
      v = 100;
      _h = h + 180;
      _s = 100;
      _v = 0;
      col = 0;
      row = 0;
      i = 0;
      rgb = [];
      ctx.clear();
      while (row < height) {
        if (col === width) {
          col = 0;
          row++;
          s = 0;
          v = Math.round(100 - row * (100 / height));
          _s = 100;
          _v = row * (100 / height);
        }
        if (s === this._pickerData.selectedHSV[1] || v === this._pickerData.selectedHSV[2]) {
          rgb = this._HSVtoRGB(_h, _s, _v);
        } else {
          rgb = this._HSVtoRGB(h, s, v);
        }
        picker.data[i] = rgb[0];
        picker.data[i + 1] = rgb[1];
        picker.data[i + 2] = rgb[2];
        picker.data[i + 3] = this._pickerData.selectedAlpha;
        col++;
        i += 4;
        s = Math.round(col * (100 / width));
        _s = Math.round(100 - col * (100 / width));
      }
      ctx.putImageData(picker, 0, 0);
      if (this._plugin.options.debug === true) {
        return this._dumpCurrentData();
      }
    };

    ColourPicker.prototype.buildSpectrum = function() {
      var ctx, currentSpectrumPosition, gradient, height, hue, i, position, positions, rgb, spectrumPosLeft, spectrumWidth, width, _i, _j, _len, _ref;
      ctx = (_ref = this._ctxObjects.spectrum) != null ? _ref : this._createCTXObject('spectrum', 'colourspectrum');
      width = ctx.canvas.width;
      height = ctx.canvas.height;
      spectrumWidth = 25;
      spectrumPosLeft = (width - spectrumWidth) / 2;
      ctx.clear();
      gradient = ctx.createLinearGradient(0, 0, 0, height);
      i = 0;
      for (hue = _i = 0; _i <= 360; hue = _i += 60) {
        rgb = this._HSVtoRGB(hue, 100, 100);
        rgb = 'rgb(' + rgb[0] + ', ' + rgb[1] + ', ' + rgb[2] + ')';
        gradient.addColorStop(i++ * 1 / 6, rgb);
      }
      ctx.fillStyle = gradient;
      ctx.fillRect(spectrumPosLeft, 0, spectrumWidth, height);
      currentSpectrumPosition = this._pickerData.selectedHSV[0] / (360 / height);
      positions = [[0, currentSpectrumPosition - 5], [10, currentSpectrumPosition], [35, currentSpectrumPosition], [45, currentSpectrumPosition - 5], [45, currentSpectrumPosition + 5], [35, currentSpectrumPosition], [10, currentSpectrumPosition], [0, currentSpectrumPosition + 5], [0, currentSpectrumPosition - 5]];
      ctx.fillStyle = ctx.strokeStyle = this._spectrumData.selectorColour;
      ctx.beginPath();
      position = positions.shift();
      ctx.moveTo(position[0], position[1]);
      for (_j = 0, _len = positions.length; _j < _len; _j++) {
        position = positions[_j];
        ctx.lineTo(position[0], position[1]);
      }
      ctx.fill();
      ctx.stroke();
      return ctx.closePath();
    };

    /* Helper functions
    */


    ColourPicker.prototype._createCTXObject = function(key, canvasElement) {
      var canvas,
        _this = this;
      if (typeof this._ctxObjects[key] === 'undefined') {
        this._ctxObjects[key] = {};
      }
      canvas = $(this._plugin.element).append(function() {
        return $(document.createElement('canvas')).attr({
          'id': canvasElement,
          'width': _this._plugin.options.elementProperties[canvasElement][0],
          'height': _this._plugin.options.elementProperties[canvasElement][1]
        });
      });
      return this._ctxObjects[key] = $("#" + canvasElement)[0].getContext('2d');
    };

    ColourPicker.prototype._createImageData = function(context, w, h) {
      var imgd;
      if (context.createImageData != null) {
        return imgd = context.createImageData(w, h);
      } else if (context.getImageData != null) {
        return imgd = context.getImageData(0, 0, w, h);
      } else {
        return imgd = {
          'width': w,
          'height': h,
          'data': []
        };
      }
    };

    ColourPicker.prototype._dumpCurrentData = function() {
      var rgb,
        _this = this;
      rgb = this._currentToRGB();
      $('#colourpickerdump').remove();
      return $('body').append(function() {
        return $(document.createElement('div')).attr('id', 'colourpickerdump').append(function() {
          return $(document.createElement('p')).text(function() {
            return "Hex: " + (_this._currentToHEX());
          });
        }).append(function() {
          return $(document.createElement('hr'));
        }).append(function() {
          return $(document.createElement('p')).text(function() {
            return "Red: " + rgb[0];
          });
        }).append(function() {
          return $(document.createElement('p')).text(function() {
            return "Green: " + rgb[1];
          });
        }).append(function() {
          return $(document.createElement('p')).text(function() {
            return "Blue: " + rgb[2];
          });
        }).append(function() {
          return $(document.createElement('hr'));
        }).append(function() {
          return $(document.createElement('p')).text(function() {
            return "Hue: " + _this._pickerData.selectedHSV[0];
          });
        }).append(function() {
          return $(document.createElement('p')).text(function() {
            return "Saturation: " + _this._pickerData.selectedHSV[1];
          });
        }).append(function() {
          return $(document.createElement('p')).text(function() {
            return "Value: " + _this._pickerData.selectedHSV[2];
          });
        });
      });
    };

    ColourPicker.prototype._HSVtoRGB = function(h, s, v) {
      var hsv;
      hsv = new ColourCalculatorHSV(h, s, v);
      return hsv.getRGB();
    };

    ColourPicker.prototype._RGBtoHSV = function(r, g, b) {
      var rgb;
      rgb = new ColourCalculatorRGB(r, g, b);
      return rgb.getHSV();
    };

    ColourPicker.prototype._currentToRGB = function() {
      var hsv;
      hsv = new ColourCalculatorHSV(this._pickerData.selectedHSV[0], this._pickerData.selectedHSV[1], this._pickerData.selectedHSV[2]);
      return hsv.getRGB();
    };

    ColourPicker.prototype._currentToHEX = function() {
      var hsv;
      hsv = new ColourCalculatorHSV(this._pickerData.selectedHSV[0], this._pickerData.selectedHSV[1], this._pickerData.selectedHSV[2]);
      return hsv.getHEX();
    };

    return ColourPicker;

  })();

  (function($, window) {
    var Plugin, defaults, document, pluginName;
    pluginName = 'LeximosiColourPicker';
    document = window.document;
    defaults = {
      callback: null,
      debug: false,
      elementProperties: {
        colourpicker: [150, 150],
        colourspectrum: [45, 150]
      },
      pickerData: {
        selectedHSV: [0, 0, 0],
        selectedAlpha: 255
      },
      spectrumData: {
        selectorColour: '#333'
      }
    };
    Plugin = (function() {

      function Plugin(element, options) {
        this.element = element;
        this.options = $.extend(true, {}, defaults, options);
        this._defaults = defaults;
        this._name = pluginName;
        this.colourPicker = new ColourPicker(this);
        this.init();
      }

      Plugin.prototype.init = function() {
        return this.colourPicker.build();
      };

      Plugin.prototype.getPlugin = function() {
        return this;
      };

      Plugin.prototype.getColourPicker = function() {
        return this.colourPicker;
      };

      return Plugin;

    })();
    return $.fn[pluginName] = function(options) {
      return this.each(function() {
        if (!$.data(this, "plugin_" + pluginName)) {
          return $.data(this, "plugin_" + pluginName, new Plugin(this, options));
        }
      });
    };
  })(jQuery, window);

  MouseTouchHandler = (function() {

    function MouseTouchHandler(element, colourPicker) {
      this.colourPicker = colourPicker;
      this.element = $(element.canvas);
      this.handle = false;
      this.register();
    }

    MouseTouchHandler.prototype.register = function() {
      var _this = this;
      return this.element.on("mousedown." + this.colourPicker._plugin._name + " touchstart." + this.colourPicker._plugin._name, function(e) {
        e.preventDefault();
        _this.handle = true;
        return _this.action(e);
      }).on("mouseup." + this.colourPicker._plugin._name + " touchend." + this.colourPicker._plugin._name, function(e) {
        e.preventDefault();
        return _this.handle = false;
      }).on("mousemove." + this.colourPicker._plugin._name + " touchmove." + this.colourPicker._plugin._name, function(e) {
        e.preventDefault();
        if (_this.handle === true) {
          return _this.action(e);
        }
      });
    };

    MouseTouchHandler.prototype._getEventPosition = function(e) {
      var offset;
      offset = this.element.offset();
      if (!e.originalEvent.changedTouches) {
        return {
          xPos: e.pageX -= offset.left,
          yPos: e.pageY -= offset.top
        };
      } else {
        return {
          xPos: e.originalEvent.changedTouches[0].pageX -= offset.left,
          yPos: e.originalEvent.changedTouches[0].pageY -= offset.top
        };
      }
    };

    return MouseTouchHandler;

  })();

  MouseTouchHandlerPicker = (function(_super) {

    __extends(MouseTouchHandlerPicker, _super);

    function MouseTouchHandlerPicker() {
      return MouseTouchHandlerPicker.__super__.constructor.apply(this, arguments);
    }

    MouseTouchHandlerPicker.prototype.action = function(e) {
      var position;
      position = this._getEventPosition(e);
      this.sat = Math.floor(position.xPos * 100 / this.element.width());
      this.val = Math.floor(100 - position.yPos * 100 / this.element.height());
      if (this.sat < 0 || this.sat > 100) {
        this.sat = this.sat < 0 ? 0 : 100;
      }
      if (this.val < 0 || this.val > 100) {
        this.val = this.val < 0 ? 0 : 100;
      }
      this.colourPicker._pickerData.selectedHSV[1] = this.sat;
      this.colourPicker._pickerData.selectedHSV[2] = this.val;
      this.colourPicker.buildPicker();
      if (this.colourPicker._plugin.options.callback != null) {
        return this.colourPicker._plugin.options.callback(this);
      }
    };

    return MouseTouchHandlerPicker;

  })(MouseTouchHandler);

  MouseTouchHandlerSpectrum = (function(_super) {

    __extends(MouseTouchHandlerSpectrum, _super);

    function MouseTouchHandlerSpectrum() {
      return MouseTouchHandlerSpectrum.__super__.constructor.apply(this, arguments);
    }

    MouseTouchHandlerSpectrum.prototype.action = function(e) {
      var position;
      position = this._getEventPosition(e);
      this.hue = Math.round(position.yPos * 360 / this.element.height());
      if (this.hue < 0 || this.hue > 359) {
        this.hue = this.hue < 0 ? 0 : 359;
      }
      this.colourPicker._pickerData.selectedHSV[0] = this.hue;
      this.colourPicker.buildPicker();
      this.colourPicker.buildSpectrum();
      if (this.colourPicker._plugin.options.callback != null) {
        return this.colourPicker._plugin.options.callback(this);
      }
    };

    return MouseTouchHandlerSpectrum;

  })(MouseTouchHandler);

  /*
  http://stackoverflow.com/a/9722502
  */


  CanvasRenderingContext2D.prototype.clear = function(preserveTransform) {
    if (preserveTransform) {
      this.save();
      this.setTransform(1, 0, 0, 1, 0, 0);
    }
    this.clearRect(0, 0, this.canvas.width, this.canvas.height);
    if (preserveTransform) {
      return this.restore();
    }
  };

}).call(this);
