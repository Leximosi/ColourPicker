// Generated by CoffeeScript 1.3.3

/*
  Project: Leximosi Colour Picker
  Description: Simple canvas and jQuery based colour picker
  Author: Erik Fr√®rejean (http://leximosi.github.com)
  License: MIT license - http://opensource.org/licenses/mit-license.php
*/


/*
Class designed to calculate between various colour formats
*/


(function() {
  var ColourCalculator, ColourCalculatorHSV, ColourCalculatorRGB, ColourPicker, MouseTouchHandler, MouseTouchHandlerPicker, MouseTouchHandlerSpectrum,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ColourCalculator = (function() {

    function ColourCalculator() {}

    /*
    Get the HEX value of the current colour
    */


    ColourCalculator.prototype.getHEX = function() {
      this._calculateHEX();
      return this.hex;
    };

    /*
    Get the HSV value of the current colour
    */


    ColourCalculator.prototype.getHSV = function(raw) {
      this._calculateHSV();
      raw = raw || false;
      if (raw !== true) {
        return [Math.round(this.h * 60), Math.round(this.s * 100), Math.round(this.v * 100)];
      } else {
        return [this.h, this.s, this.v];
      }
    };

    /*
    Get the RGB value of the current colour
    */


    ColourCalculator.prototype.getRGB = function(raw) {
      this._calculateRGB();
      raw = raw || false;
      if (raw !== true) {
        return [Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255)];
      } else {
        return [this.r, this.g, this.b];
      }
    };

    /*
    Get the RGBA value of the current colour
    */


    ColourCalculator.prototype.getRGBA = function() {
      var raw;
      this._calculateRGB();
      raw = raw || false;
      if (raw !== true) {
        return [Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255), this.alpha];
      } else {
        return [this.r, this.g, this.b, this.alpha];
      }
    };

    /*
    Build the HEX string
    */


    ColourCalculator.prototype._calculateHEX = function() {
      var c, rgb, _i, _len, _results;
      rgb = this.getRGB();
      this.hex = '#';
      _results = [];
      for (_i = 0, _len = rgb.length; _i < _len; _i++) {
        c = rgb[_i];
        _results.push(this.hex += ("0" + parseInt(c, 10).toString(16)).slice(-2));
      }
      return _results;
    };

    /*
    Transform an RGB colour into its HSV value
    */


    ColourCalculator.prototype._calculateHSV = function() {
      var delta, max, min;
      if (typeof this.s !== "undefined") {
        return;
      }
      min = Math.min(this.r, this.g, this.b);
      max = Math.max(this.r, this.g, this.b);
      delta = max - min;
      this.v = max;
      if (max === 0) {
        this.s = 0;
        return this.h = -1 / 60;
      } else {
        this.s = delta / max;
        if (this.r === max) {
          return this.h = (this.g - this.b) / delta;
        } else if (this.g === max) {
          return this.h = 2 + (this.b - this.r) / delta;
        } else {
          return this.h = 4 + (this.r - this.g) / delta;
        }
      }
    };

    /*
    Transform an HSV colour into its RGB value
    Per: http://en.wikipedia.org/wiki/HSL_and_HSV#From_HSV
    */


    ColourCalculator.prototype._calculateRGB = function() {
      var _f, _i, _p, _q, _t;
      if (typeof this.r !== "undefined") {
        return;
      }
      if (this.s === 0) {
        return this.r = this.g = this.b = this.v;
      } else {
        _i = Math.floor(this.h);
        _f = this.h - _i;
        _p = this.v * (1 - this.s);
        _q = this.v * (1 - this.s * _f);
        _t = this.v * (1 - this.s * (1 - _f));
        switch (_i) {
          case 0:
            this.r = this.v;
            this.g = _t;
            return this.b = _p;
          case 1:
            this.r = _q;
            this.g = this.v;
            return this.b = _p;
          case 2:
            this.r = _p;
            this.g = this.v;
            return this.b = _t;
          case 3:
            this.r = _p;
            this.g = _q;
            return this.b = this.v;
          case 4:
            this.r = _t;
            this.g = _p;
            return this.b = this.v;
          case 5:
            this.r = this.v;
            this.g = _p;
            return this.b = _q;
        }
      }
    };

    return ColourCalculator;

  })();

  /*
  Create a ColourCalculate object which is initialised by a
  HSV value.
  */


  ColourCalculatorHSV = (function(_super) {

    __extends(ColourCalculatorHSV, _super);

    function ColourCalculatorHSV(h, s, v) {
      this.h = h;
      this.s = s;
      this.v = v;
      while (this.h >= 360) {
        this.h -= 360;
      }
      while (this.h < 0) {
        this.h += 360;
      }
      if (this.s < 0 || this.s > 100) {
        this.s = this.s < 0 ? 0 : 100;
      }
      if (this.v < 0 || this.v > 100) {
        this.v = this.v < 0 ? 0 : 100;
      }
      this.h /= 60;
      this.s /= 100;
      this.v /= 100;
    }

    return ColourCalculatorHSV;

  })(ColourCalculator);

  /*
  Create a ColourCalculate object which is initialised by a
  RGB value.
  */


  ColourCalculatorRGB = (function(_super) {

    __extends(ColourCalculatorRGB, _super);

    function ColourCalculatorRGB(r, g, b, alpha) {
      var _ref;
      this.r = r;
      this.g = g;
      this.b = b;
      this.alpha = alpha;
      this.r /= 255;
      this.g /= 255;
      this.b /= 255;
      this.alpha = (_ref = this.alpha) != null ? _ref : 255;
    }

    return ColourCalculatorRGB;

  })(ColourCalculator);

  /*
  Main ColourPicker class
  */


  ColourPicker = (function() {

    function ColourPicker(_plugin) {
      this._plugin = _plugin;
      this._ctxObjects = {};
      this._pickerData = this._plugin.options.pickerData;
      this._spectrumData = this._plugin.options.spectrumData;
    }

    /*
    Build the complete colourpicker
    */


    ColourPicker.prototype.build = function() {
      var _ref, _ref1;
            if ((_ref = this._ctxObjects.spectrum) != null) {
        _ref;

      } else {
        this._createCTXObject('spectrum', 'colourspectrum');
      };
            if ((_ref1 = this._ctxObjects.picker) != null) {
        _ref1;

      } else {
        this._createCTXObject('picker', 'colourpicker');
      };
      this.mouseTouchHandlers = {
        'picker': new MouseTouchHandlerPicker(this, 'picker'),
        'spectrum': new MouseTouchHandlerSpectrum(this, 'spectrum')
      };
      this.buildSpectrum();
      this.buildPicker();
      return this._applyStyle();
    };

    /*
    Create the canvas that is used to select the colour
    */


    ColourPicker.prototype.buildPicker = function(xPos, yPos) {
      var col, crosshair, ctx, h, height, i, picker, rgb, row, s, v, width;
      ctx = this._ctxObjects.picker;
      width = ctx.canvas.width;
      height = ctx.canvas.height;
      picker = this._createImageData(ctx, width, height);
      h = this._pickerData.selectedHSV[0];
      s = 0;
      v = 100;
      col = 0;
      row = 0;
      i = 0;
      rgb = [];
      ctx.clear();
      crosshair = this._plugin.options.selectors.picker(this, picker, xPos, yPos);
      while (row < height) {
        if (col === width) {
          col = 0;
          row++;
          s = 0;
          v = Math.round(100 - row * (100 / height));
        }
        rgb = this._HSVtoRGB(h, s, v);
        if (__indexOf.call(crosshair, i) >= 0) {
          rgb[0] = 255 - rgb[0];
          rgb[1] = 255 - rgb[1];
          rgb[2] = 255 - rgb[2];
        }
        picker.data[i] = rgb[0];
        picker.data[i + 1] = rgb[1];
        picker.data[i + 2] = rgb[2];
        picker.data[i + 3] = this._pickerData.selectedAlpha;
        col++;
        i += 4;
        s = Math.round(col * (100 / width));
      }
      ctx.putImageData(picker, 0, 0);
      if (this._plugin.options.debug === true) {
        return this._dumpCurrentData();
      }
    };

    /*
    Create the spectrum bar
    */


    ColourPicker.prototype.buildSpectrum = function() {
      var ctx, gradient, height, hue, i, rgb, spectrumPosLeft, spectrumWidth, width, _i;
      ctx = this._ctxObjects.spectrum;
      width = ctx.canvas.width;
      height = ctx.canvas.height;
      spectrumWidth = 25;
      spectrumPosLeft = (width - spectrumWidth) / 2;
      ctx.clear();
      gradient = ctx.createLinearGradient(0, 0, 0, height);
      i = 0;
      for (hue = _i = 0; _i <= 360; hue = _i += 60) {
        rgb = this._HSVtoRGB(hue, 100, 100);
        rgb = 'rgb(' + rgb[0] + ', ' + rgb[1] + ', ' + rgb[2] + ')';
        gradient.addColorStop(i++ * 1 / 6, rgb);
      }
      ctx.fillStyle = gradient;
      ctx.fillRect(spectrumPosLeft, 0, spectrumWidth, height);
      return this._plugin.options.selectors.spectrum(this);
    };

    /*
    Style the picker
    */


    ColourPicker.prototype._applyStyle = function() {
      var picker, spectrum;
      if (this._plugin.options.stylecss === true) {
        return;
      }
      picker = $(this._ctxObjects.picker.canvas);
      spectrum = $(this._ctxObjects.spectrum.canvas);
      spectrum.css({
        'border': '1px solid #888',
        'border-right': 'none',
        '-webkit-border-top-left-radius': '5px',
        '-webkit-border-bottom-left-radius': '5px',
        '-moz-border-radius-topleft': '5px',
        '-moz-border-radius-bottomleft': '5px',
        'border-top-left-radius': '5px',
        'border-bottom-left-radius': '5px',
        'cursor': 'move'
      });
      picker.css({
        'border': '1px solid #888',
        'border-right': 'none',
        'border-left': 'none',
        'cursor': 'crosshair'
      });
      return $(this._plugin.element).css({
        'width': picker.outerWidth(true) + spectrum.outerWidth(true) + 'px',
        'height': picker.outerHeight(true) > spectrum.outerHeight(true) ? picker.outerHeight(true) + 'px' : spectrum.outerHeight(true) + 'px',
        '-moz-box-shadow': '10px 10px 5px #888',
        '-webkit-box-shadow': '10px 10px 5px #888',
        'box-shadow': '10px 10px 5px #888'
      });
    };

    /*
    Calculate the pixel positions for the selector
    */


    ColourPicker.prototype.createDefaultPickerSelectorPixels = function(imgData, xPos, yPos) {
      var col, pixels, row;
      if (typeof xPos === "undefined") {
        xPos = Math.floor(this._pickerData.selectedHSV[1] * (imgData.width / 100));
        yPos = Math.floor(imgData.height - this._pickerData.selectedHSV[2] * (imgData.height / 100));
      }
      col = row = 0;
      pixels = (function() {
        var _results;
        _results = [];
        while (row++ <= imgData.height) {
          if (row === yPos) {
            _results.push((function() {
              var _results1;
              _results1 = [];
              while (col++ <= imgData.width) {
                _results1.push((row * imgData.width * 4) + (col * 4));
              }
              return _results1;
            })());
          } else {
            _results.push((row * imgData.width * 4) + (xPos * 4));
          }
        }
        return _results;
      })();
      return pixels.flatten();
    };

    /*
    Draw the default Spectrum selector
    */


    ColourPicker.prototype.createDefaultSpectrumSelector = function(yPos) {
      var ctx, height, position, positions, _i, _len;
      ctx = this._ctxObjects.spectrum;
      height = ctx.canvas.height;
      if (typeof yPos === "undefined") {
        yPos = Math.floor(this._pickerData.selectedHSV[0] * (height / 360));
      }
      positions = [[0, yPos - 5], [10, yPos], [35, yPos], [45, yPos - 5], [45, yPos + 5], [35, yPos], [10, yPos], [0, yPos + 5], [0, yPos - 5]];
      ctx.fillStyle = this._currentToHEX();
      ctx.strokeStyle = this._spectrumData.selectorColour;
      ctx.beginPath();
      position = positions.shift();
      ctx.moveTo(position[0], position[1]);
      for (_i = 0, _len = positions.length; _i < _len; _i++) {
        position = positions[_i];
        ctx.lineTo(position[0], position[1]);
      }
      ctx.fill();
      ctx.stroke();
      return ctx.closePath();
    };

    /* Helper functions
    */


    /*
    Create the canvas and setup the "context"
    */


    ColourPicker.prototype._createCTXObject = function(key, canvasElement) {
      var canvas,
        _this = this;
      if (typeof this._ctxObjects[key] === 'undefined') {
        this._ctxObjects[key] = {};
      }
      canvas = $(this._plugin.element).append(function() {
        return $(document.createElement('canvas')).attr({
          'id': canvasElement,
          'width': _this._plugin.options.elementProperties[canvasElement][0],
          'height': _this._plugin.options.elementProperties[canvasElement][1]
        });
      });
      return this._ctxObjects[key] = $("#" + canvasElement)[0].getContext('2d');
    };

    /*
    Not all browsers implement createImageData. On such browsers we obtain the 
    ImageData object using the getImageData method. The worst-case scenario is 
    to create an object *similar* to the ImageData object and hope for the best 
    luck.
    */


    ColourPicker.prototype._createImageData = function(context, w, h) {
      var imgd;
      if (context.createImageData != null) {
        return imgd = context.createImageData(w, h);
      } else if (context.getImageData != null) {
        return imgd = context.getImageData(0, 0, w, h);
      } else {
        return imgd = {
          'width': w,
          'height': h,
          'data': []
        };
      }
    };

    /*
    Create a DOM element that displays all internal data
    */


    ColourPicker.prototype._dumpCurrentData = function() {
      var rgb,
        _this = this;
      rgb = this._currentToRGB();
      $('#colourpickerdump').remove();
      return $('body').append(function() {
        return $(document.createElement('div')).attr('id', 'colourpickerdump').append(function() {
          return $(document.createElement('p')).text(function() {
            return "Hex: " + (_this._currentToHEX());
          });
        }).append(function() {
          return $(document.createElement('hr'));
        }).append(function() {
          return $(document.createElement('p')).text(function() {
            return "Red: " + rgb[0];
          });
        }).append(function() {
          return $(document.createElement('p')).text(function() {
            return "Green: " + rgb[1];
          });
        }).append(function() {
          return $(document.createElement('p')).text(function() {
            return "Blue: " + rgb[2];
          });
        }).append(function() {
          return $(document.createElement('hr'));
        }).append(function() {
          return $(document.createElement('p')).text(function() {
            return "Hue: " + _this._pickerData.selectedHSV[0];
          });
        }).append(function() {
          return $(document.createElement('p')).text(function() {
            return "Saturation: " + _this._pickerData.selectedHSV[1];
          });
        }).append(function() {
          return $(document.createElement('p')).text(function() {
            return "Value: " + _this._pickerData.selectedHSV[2];
          });
        });
      });
    };

    /*
    HSV to RGB shortcut
    */


    ColourPicker.prototype._HSVtoRGB = function(h, s, v) {
      var hsv;
      hsv = new ColourCalculatorHSV(h, s, v);
      return hsv.getRGB();
    };

    /*
    RGB to HSV shortcut
    */


    ColourPicker.prototype._RGBtoHSV = function(r, g, b) {
      var rgb;
      rgb = new ColourCalculatorRGB(r, g, b);
      return rgb.getHSV();
    };

    /*
    Current to RGB shortcut
    */


    ColourPicker.prototype._currentToRGB = function() {
      var hsv;
      hsv = new ColourCalculatorHSV(this._pickerData.selectedHSV[0], this._pickerData.selectedHSV[1], this._pickerData.selectedHSV[2]);
      return hsv.getRGB();
    };

    /*
    Current to HEX shortcut
    */


    ColourPicker.prototype._currentToHEX = function() {
      var hsv;
      hsv = new ColourCalculatorHSV(this._pickerData.selectedHSV[0], this._pickerData.selectedHSV[1], this._pickerData.selectedHSV[2]);
      return hsv.getHEX();
    };

    return ColourPicker;

  })();

  (function($, window) {
    var Plugin, defaults, document, pluginName;
    pluginName = 'LeximosiColourPicker';
    document = window.document;
    defaults = {
      debug: false,
      elementProperties: {
        colourpicker: [150, 150],
        colourspectrum: [45, 150]
      },
      events: {
        picker: null,
        spectrum: null
      },
      selectors: {
        picker: function(cp, imgData, xPos, yPos) {
          return cp.createDefaultPickerSelectorPixels(imgData, xPos, yPos);
        },
        spectrum: function(cp, xPos, yPos) {
          return cp.createDefaultSpectrumSelector(xPos, yPos);
        }
      },
      pickerData: {
        selectedHSV: [0, 0, 0],
        selectedAlpha: 255
      },
      spectrumData: {
        selectorColour: '#333'
      },
      stylecss: false
    };
    /*
    The actual plugin constructor
    */

    Plugin = (function() {

      function Plugin(element, options) {
        this.element = element;
        this.options = $.extend(true, {}, defaults, options);
        this._defaults = defaults;
        this._name = pluginName;
        this.colourPicker = new ColourPicker(this);
        this.init();
      }

      Plugin.prototype.init = function() {
        return this.colourPicker.build();
      };

      Plugin.prototype.getPlugin = function() {
        return this;
      };

      Plugin.prototype.getColourPicker = function() {
        return this.colourPicker;
      };

      return Plugin;

    })();
    return $.fn[pluginName] = function(options) {
      return this.each(function() {
        if (!$.data(this, "plugin_" + pluginName)) {
          return $.data(this, "plugin_" + pluginName, new Plugin(this, options));
        }
      });
    };
  })(jQuery, window);

  /*
  Handler class for mouse and touch input
  */


  MouseTouchHandler = (function() {

    function MouseTouchHandler(colourPicker, element) {
      var bindings, callback, event, _i, _len, _ref, _ref1,
        _this = this;
      this.colourPicker = colourPicker;
      this.element = $(this.colourPicker._ctxObjects[element].canvas);
      this.handle = false;
      this.register();
      if (!(this.colourPicker._plugin.options.events[element] != null)) {
        return;
      }
      _ref = this.colourPicker._plugin.options.events[element];
      for (bindings in _ref) {
        callback = _ref[bindings];
        _ref1 = bindings.split(" ");
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          event = _ref1[_i];
          this.element.on("" + event + "." + this.colourPicker._plugin._name, function(e) {
            return callback(e, _this);
          });
        }
      }
    }

    /*
    Register all events
    */


    MouseTouchHandler.prototype.register = function() {
      var _this = this;
      return this.element.on("mousedown." + this.colourPicker._plugin._name + " touchstart." + this.colourPicker._plugin._name, function(e) {
        e.preventDefault();
        _this.handle = true;
        return _this.action(e);
      }).on("mouseup." + this.colourPicker._plugin._name + " touchend." + this.colourPicker._plugin._name, function(e) {
        e.preventDefault();
        return _this.handle = false;
      }).on("mousemove." + this.colourPicker._plugin._name + " touchmove." + this.colourPicker._plugin._name, function(e) {
        e.preventDefault();
        if (_this.handle === true) {
          return _this.action(e);
        }
      });
    };

    /*
    Determine the position of the event on the canvas
    */


    MouseTouchHandler.prototype._getEventPosition = function(e) {
      var offset;
      offset = this.element.offset();
      if (!e.originalEvent.changedTouches) {
        return this.eventPosition = {
          xPos: e.pageX -= offset.left,
          yPos: e.pageY -= offset.top
        };
      } else {
        return this.eventPosition = {
          xPos: e.originalEvent.changedTouches[0].pageX -= offset.left,
          yPos: e.originalEvent.changedTouches[0].pageY -= offset.top
        };
      }
    };

    return MouseTouchHandler;

  })();

  /*
  Mouse and Touch handler for the Colour Picker canvas
  */


  MouseTouchHandlerPicker = (function(_super) {

    __extends(MouseTouchHandlerPicker, _super);

    function MouseTouchHandlerPicker() {
      return MouseTouchHandlerPicker.__super__.constructor.apply(this, arguments);
    }

    MouseTouchHandlerPicker.prototype.action = function(e) {
      var position;
      position = this._getEventPosition(e);
      this.sat = Math.floor(position.xPos * 100 / this.element.width());
      this.val = Math.floor(100 - position.yPos * 100 / this.element.height());
      if (this.sat < 0 || this.sat > 100) {
        this.sat = this.sat < 0 ? 0 : 100;
      }
      if (this.val < 0 || this.val > 100) {
        this.val = this.val < 0 ? 0 : 100;
      }
      this.colourPicker._pickerData.selectedHSV[1] = this.sat;
      this.colourPicker._pickerData.selectedHSV[2] = this.val;
      this.colourPicker.buildPicker(position.xPos, position.yPos);
      if (this.colourPicker._plugin.options.callback != null) {
        return this.colourPicker._plugin.options.callback(this);
      }
    };

    return MouseTouchHandlerPicker;

  })(MouseTouchHandler);

  /*
  Mouse and Touch handler for the Colour Spectrum canvas
  */


  MouseTouchHandlerSpectrum = (function(_super) {

    __extends(MouseTouchHandlerSpectrum, _super);

    function MouseTouchHandlerSpectrum() {
      return MouseTouchHandlerSpectrum.__super__.constructor.apply(this, arguments);
    }

    MouseTouchHandlerSpectrum.prototype.action = function(e) {
      var position;
      position = this._getEventPosition(e);
      this.hue = Math.round(position.yPos * 360 / this.element.height());
      if (this.hue < 0 || this.hue > 359) {
        this.hue = this.hue < 0 ? 0 : 359;
      }
      this.colourPicker._pickerData.selectedHSV[0] = this.hue;
      this.colourPicker.buildPicker();
      this.colourPicker.buildSpectrum();
      if (this.colourPicker._plugin.options.callback != null) {
        return this.colourPicker._plugin.options.callback(this);
      }
    };

    return MouseTouchHandlerSpectrum;

  })(MouseTouchHandler);

  /*
  Based on underscore.js
  */


  Array.prototype.flatten = function(_flatten) {
    _flatten = _flatten || [];
    $.each(this, function(index, value) {
      if ($.isArray(value)) {
        return value.flatten(_flatten);
      } else {
        return _flatten.push(value);
      }
    });
    return _flatten;
  };

  /*
  http://stackoverflow.com/a/9722502
  */


  CanvasRenderingContext2D.prototype.clear = function(preserveTransform) {
    if (preserveTransform) {
      this.save();
      this.setTransform(1, 0, 0, 1, 0, 0);
    }
    this.clearRect(0, 0, this.canvas.width, this.canvas.height);
    if (preserveTransform) {
      return this.restore();
    }
  };

}).call(this);
